#include <stdio.h>
#include <Windows.h>
#include <assert.h>
#include <string.h>

#pragma warning(disable:4996)

// 位段的成员可以是int , unsigned int, 或是 char(属于整形家族)类型
// 位段的空间是按照需要以4字节(int)或者1个字节(char)的方式来开辟的
// 位段涉及很多不确定的因素,位段是不跨平台的, 注意可移植的程序应该避免使用位段
// 位段里的成员的类型都是一样的
// 位段的名字后带冒号:,冒号后带数字
// 位段里定义好的某一个成员只会使用一个整形或者char型的若干bit位, 
// bit位的个数由冒号后所跟的数字决定
// int_a:2; 定义32 个比特位,而只用其中的2个

struct S{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
int main1(){
	printf("%d\n", sizeof(struct S));// 大小为3个字节
	system("pause");
	return 0;
}
int main(){
	struct S s = { 0 };
	s.a = 10;// 内部存的不是1010, 而是010
	s.b = 12;// 内部存的是1100
	s.c = 3;// 内部存的不是011 而是00011
	s.d = 4;// 存的不是100 而是0100 
	// 全都是根据之前分配好的bit位进行存放

	printf("%d\n", sizeof(struct S));

	system("pause");
	return 0;
}
// 每一个元素都是char型,扩增的基本单位为1个字节 开辟8个bit位 
// a占3个,具体位置分配在哪里不确定,假设从最右端开始(从最左边也可以)
// 内存分配时是与平台有关的 是与硬件有关的,这就叫做移植性问题

// 跟结构相比, 位段可以达到同样的效果, 可以很好的节省空间, 但是与跨平台的问题存在

// 大小端问题以字节为基本单位, 不考虑bit位问题
// int位段被当成右符号还是无符号数是不确定的
// 位段中最大位的数目不能确定(16位机器最大16,32位机器最大32, 写成27, 在16位机器会出现问题)
// 位段中的成员在内存中从左向右分配, 还是从右向左分配尚未定义
// 当一个结构包含两个位段, 第二个位段成员比较大,无法容纳第一个位段剩余的位时,
// 是舍弃剩余的为还是利用,这是不确定的

// 位段的应用 => 报头(快递单)



















